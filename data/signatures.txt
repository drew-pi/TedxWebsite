The signature solves the issue of identity trust. How can we trust that the person promising to send us the money is really the person that will send the money. (i.e if on our friend's ledger, how can we be sure that if it says that “Ann is sending Bob 5 dollars”, it is really Ann who wrote that she will send Bob that money). This is fixed using Signatures and the Elliptic Curve Digital Signature Algorithm. This is an example of asymmetric cryptography because there are two separate keys required. The private or secret key (sk) and the public key (pk). The public key is visible to everyone, anyone can see that this is your public key, however the private key is completely private and revealing it publicly would break the encryption. To prove that the person sending money is actually that person, they have to sign the transaction with their secret key. This asymmetric cryptographic algorithm (ECDSA) works in a way that this signature is verifiable by the public key. The message created by the secret key and the transaction, can be verified using the public key and transaction data and of course the actual message to see if it was really created by the secret key associated with the public key. So in this transaction system, the person (let's say Ann) isn’t actually Ann, it is the sk and pk associated with that account. People may stay anonymous, by not claiming a public key “publicly”, but you will always know that it is that account associated with the two keys


The algorithm exploits the fact that Elliptic curves are extremely hard to predict by traditional binary based computers. In this asymmetric cryptographic algorithm the public key is the curve (an elliptic curve with an equation y^2 = x^3 + Ax + B) and the starting point (let's call it A) on that curve and an endpoint (lets call it Z), all x,y pairs that satisfy the equation. To get to the endpoint from the start point, a dot operation is performed an “n” number of times. The dot operation is the multiplication of two vectors to find their maximum vector. On Elliptic curves it has the effect of finding a point (point C) in common between two values (A and another point). Then because of the graph's symmetrical nature, if you dot product the resulting point (point C) with the original point (A in this case) you get a point reflected across the axis of symmetry. Without that “another point” that you start doing dot products with, it is incredibly hard to find the number of times you need to do a dot operation (n) to get Z. So backwards engineering is very difficult without having the original number n. Thus this algorithm allows you to use the number n, to “sign” a message and see that this number “n” is the right value for a given public key holding information about the graph and its starting/end points without ever revealing the number “n”. 

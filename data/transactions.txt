Timestamps solves the transaction copy problem. How do we know that someone that was paid money won’t just copy the previous transaction and bypass the entire signature system (i.e if on a friends ledger, “Ann sent Bob 5 dollars” and signed it with her secret key, how can we stop Bob from just copying and pasting this transaction indefinitely since the signature will be the same every time). We can fix this problem by using a timestamp to differentiate each transaction from every other. Simply put, each transaction is stamped with the time that it was created. For example, let's say a transaction was made on April 1st, 2023 at 12:30.58PM, some data will be added to the transaction to mark its uniqueness. In practice it is slightly more complicated to make sure that no message has the same timestamp data and instead of just a timestamp it is more used as a unique ID and it is found in the same message signature data that was signed by the private key, in a sort of conglomerate signature identifier.


Buying in solves the issue of overspending and someone promising to pay money that they do not have. How do we know that if someone says that they own someone else money that they will actually pay that money (i.e if on a friend ledger, “Ann sent Bob 5 dollars” and signed everything with a timestamp, but Ann does not actually have 5 dollars, how would this ledger know that they don’t have those 5 dollars). This is solved by having everyone buy in the special currency, in the above example dollars, but in reality a cryptocurrency such as Bitcoin or Ethereum. Thus no one can have any money outside of this blockchain and thus they cannot lie about any money existing. If someone (let's say Ann) sends 5 dollars to Bob, but she does not have that 5 dollars, that transaction would be invalid and would not go through. As invalid as if she did not sign it or it was copied multiple times. 